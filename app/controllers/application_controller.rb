# Copyright 2014 Square Inc.
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.

# @abstract
#
# Superclass for all controllers in the application. Contains methods common to
# each controller, handles authentication, and defines failsafe responses.
# Unless otherwise noted in the controller documentation, all controllers follow
# the RESTful resource format as implemented in Rails.
#
# Supported Formats
# =================
#
# In general, the following formats are supported: HTML (`text/html`) and JSON
# (`application/json`). JSON requests are considered "API requests."
#
# Formats are indicated by the extension portion of the URL (e.g., ".json"), or
# the `Accepts` header. If no extension or header is given, HTML is assumed.
#
# Typical Responses
# =================
#
# Unless otherwise indicated by individual action method documentation, any
# RESTful request and response will follow the form shown below:
#
# All Actions
# -----------
#
# ### Record was successfully created
#
# If a record passes validation and is created, then...
#
# * for HTML requests, the response is a 302 Found redirect to the record's
#   `show` page.
# * for API requests, the status code 201 Created is returned. The body is a
#   representation of the resource in the API format.
#
# ### Record successfully updated
#
# If a record passes validation and is updated, then...
#
# * for HTML requests, the response is a 302 Found redirect to the record's
#   `show` page.
# * for API requests, the status code 200 OK is returned. The body is a
#   representation of the resource in the API format.
#
# ### Record destroyed
#
# If a record is destroyed, then...
#
# * for HTML requests, the response is a 302 Found redirect to some relevant
#   destination.
# * for API requests, the status code 204 No Content is returned. The body is
#   empty.
#
# ### Record not found
#
# If a record cannot be found, the status code 404 Not Found is returned. For
# HTML requests, a 404 page is rendered; for all other requests, no content is
# returned.
#
# ### Invalid field provided
#
# If an unknown or a protected field is included in a `create` or `update`
# request, then...
#
# * for HTML requests, the response is a 302 Found redirect to the root URL. A
#   flash alert is added indicating that the request was malformed.
# * for API requests, the status code 400 Bad Request is returned. The body is
#   empty.
#
# ### Record failed to validate
#
# If a record fails to validate during a `create` or `update` request, then...
#
# * for HTML requests, the form is re-rendered (without a redirect), and the
#   HTML is updated to indicate which fields are in error (status 200 OK).
# * for API requests, the status code 422 Unprocessable Entity is returned. The
#   body is a hash mapping model names (such as `project`) to a hash mapping
#   field names (such as `name`) to an array of error description fragments
#   (such as `is required`). Example:
#
# ```` json
# {
#   "project":{
#     "name":["is required"],
#     "repository_url":["is too long", "is not a valid URL"]
#   },
#   "user":{
#     "username":["is taken"]
#   }
# }
# ````
#
# ### Authentication required
#
# If the user is not authenticated or has an incorrect role, then...
#
# * for HTML requests, the response is a 302 Found redirect to the login page.
# * for API requests, the satus code 401 Unauthorized is returned. The body is
#   empty.
#
# CSRF Protection
# ===============
#
# All non-`GET` requests (HTML and API) must contain a correct authenticity
# token parameter. If your form is generated prior to the time of request, you
# can use the CSRF meta tags generated by the `csrf_meta_tags` function in
# Rails.

class ApplicationController < ActionController::Base
  protect_from_forgery
  self.responder = JsonDetailResponder

  before_filter :authenticate_user!

  include Squash::Ruby::ControllerMethods
  enable_squash_client

  rescue_from(ActiveRecord::RecordNotFound) do
    respond_to do |format|
      format.html { render file: Rails.root.join('public/404.html'), status: :not_found }
      format.any { head :not_found }
    end
  end

  protected

  # `before_filter` that requires that a user be logged in and have the role of
  # translator.

  def translator_required
    if current_user.try!(:translator?)
      return true
    else
      respond_to do |format|
        format.html { redirect_to root_url, alert: t('controllers.application.translator_required') }
        format.any { head :forbidden }
      end
      return false
    end
  end

  # `before_filter` that requires that a user be logged in and have the role of
  # monitor.

  def monitor_required
    if current_user.try!(:monitor?)
      return true
    else
      respond_to do |format|
        format.html { redirect_to root_url, alert: t('controllers.application.monitor_required') }
        format.any { head :forbidden }
      end
      return false
    end
  end

  # `before_filter` that requires that a user be logged in and have the role of
  # reviewer.

  def reviewer_required
    if current_user.try!(:reviewer?)
      return true
    else
      respond_to do |format|
        format.html { redirect_to root_url, alert: t('controllers.application.reviewer_required') }
        format.any { head :forbidden }
      end
      return false
    end
  end

  # `before_filter` that requires that a user be logged in and have the role of
  # administrator.

  def admin_required
    if current_user.try!(:admin?)
      return true
    else
      respond_to do |format|
        format.html { redirect_to root_url, alert: t('controllers.application.admin_required') }
        format.any { head :forbidden }
      end
      return false
    end
  end

  # `before_filter` that requires that a user be logged in and have the role of
  # monitor or reviewer.

  def monitor_or_reviewer_required
    if current_user.try!(:monitor?) or current_user.try!(:reviewer?)
      return true
    else
      respond_to do |format|
        format.html { redirect_to root_url, alert: t('controllers.application.monitor_or_reviewer_required') }
        format.any { head :forbidden }
      end
      return false
    end
  end

  # @private
  def after_sign_out_path_for(resource_or_scope)
    new_user_session_url
  end

  # @private
  def fix_empty_arrays(*fields)
    options = fields.extract_options!

    fields.each do |field|
      catch :next_field do
        path = Array.wrap(field)
        ary  = params
        path[0..-2].each do |element|
          ary = ary[element]
          throw :next_field unless ary
        end
        ary[path.last] ||= []
        ary[path.last].reject!(&:blank?) unless options[:preserve_blank]
      end
    end
  end

  # @private
  def fix_empty_hashes(*fields)
    options = fields.extract_options!

    fields.each do |field|
      catch :next_field do
        path = Array.wrap(field)
        ary  = params
        path[0..-2].each do |element|
          ary = ary[element]
          throw :next_field unless ary
        end
        ary[path.last] ||= {}
        ary[path.last].each { |k,v| ary[path.last][k] = options[:empty_placeholder] if v.blank? }
        ary[path.last].each { |k,v| v.reject!(&:blank?) } if options[:reject_blank_value_elements]
        ary[path.last].each { |k,v| ary[path.last].delete(k) if v.blank? } unless options[:preserve_blank]
        ary[path.last].each { |k,v| ary[path.last][k] = options[:map_values].(v) } if options[:map_values]
      end
    end
  end
end
